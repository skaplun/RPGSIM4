"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self&&self;var t=function(t,n){return t(n={exports:{}},n.exports),n.exports}((function(t,n){
/*! axis.js v1.2.1 | (c) 2016 @toddmotto | https://github.com/toddmotto/axis */
t.exports=function(){var t={},n="Array Object String Date RegExp Function Boolean Number Null Undefined".split(" ");function r(){return Object.prototype.toString.call(this).slice(8,-1)}for(var e=n.length;e--;)t["is"+n[e]]=function(t){return function(n){return r.call(n)===t}}(n[e]);return t}()})),n=t.isObject,r=t.isNumber,e=t.isArray,i=t.isString;function o(t,n){return n+t*(1&n)>>1}function s(t,n){return(t%n+n)%n}function u(t,n){if(!/^(N|S)?(E|W)?$/i.test(t))throw new Error("Invalid compass direction: ".concat(t,". Choose from E, SE, S, SW, W, NW, N or NE."));if(n=n.toLowerCase(),t=t.toUpperCase(),"pointy"===n&&["N","S"].includes(t))throw new Error("Direction ".concat(t," is ambiguous for pointy hexes. Did you mean ").concat(t,"E or ").concat(t,"W?"));if("flat"===n&&["E","W"].includes(t))throw new Error("Direction ".concat(t," is ambiguous for flat hexes. Did you mean N").concat(t," or S").concat(t,"?"));return{pointy:{E:0,SE:1,SW:2,W:3,NW:4,NE:5},flat:{SE:0,S:1,SW:2,NW:3,N:4,NE:5}}[n][t]}function c(t,n){return r(t)||r(n)?r(t)?r(n)||(n=t):t=n:t=n=0,{x:t,y:n}}const a=[{q:1,r:0,s:-1},{q:0,r:1,s:-1},{q:-1,r:1,s:0},{q:-1,r:0,s:1},{q:0,r:-1,s:1},{q:1,r:-1,s:0}],h=[{q:2,r:-1,s:-1},{q:1,r:1,s:-2},{q:-1,r:2,s:-1},{q:-2,r:1,s:1},{q:-1,r:-1,s:2},{q:1,r:-2,s:1}],f={q:1e-6,r:1e-6,s:-2e-6};function l(t){return r(t)?this[t]:this[this.indexOf(t)]}function d({isValidHex:t}){return function(n,e){if(!t(e))return this;const i=r(n)?n:this.indexOf(n);return i<0?this.push(e):this[i]=e,this}}function x(t,n){const r=t.distance(n),e=1/Math.max(r,1);let i=[];for(let o=0;o<=r;o++){const r=t.nudge().lerp(n.nudge(),e*o).round();i.push(this.get(r))}return i}function y({isValidHex:t}){return function(n,r=0,e=!0){if(!t(n))throw new Error("Invalid center hex: ".concat(n,"."));if(!this.get(n))throw new Error("Center hex with coordinates ".concat(n," not present in grid."));let i=[];for(let t=-r;t<=r;t++)for(let o=Math.max(-r,-t-r);o<=Math.min(r,-t+r);o++){const r=this.get(n.cubeToCartesian({q:n.q+t,r:n.r+o}));n.equals(r)&&!e||i.push(r)}return i.filter(Boolean)}}function p({isValidHex:t,signedModulo:n,compassToNumberDirection:r}){return function(e,o="all",s=!1){if(!t(e))throw new Error("Invalid hex: ".concat(e,"."));const u=s?h:a;return"all"===o&&(o=[0,1,2,3,4,5]),[].concat(o).map(t=>{i(t)&&(t=r(t,e.orientation)),(t<0||t>5)&&(t=n(t,6));const{q:o,r:s}=u[t];return this.get(e.cubeToCartesian({q:e.q+o,r:e.r+s}))})}}function g(){if(0===this.length)return 0;const{0:t,length:n,[n-1]:r}=this[0].isPointy()?[...this].sort((t,n)=>n.s-t.s||t.q-n.q):[...this].sort((t,n)=>t.q-n.q);return r.toPoint().x-t.toPoint().x+this[0].width()}function b(){if(0===this.length)return 0;const{0:t,length:n,[n-1]:r}=this[0].isPointy()?[...this].sort((t,n)=>t.r-n.r):[...this].sort((t,n)=>n.s-t.s||t.r-n.r);return r.toPoint().y-t.toPoint().y+this[0].height()}function q({Hex:t}){return function(n,r){return t().fromPoint(n,r)}}function P({Grid:t,Hex:n}){return function({width:r,height:e,start:i,direction:o=1,onCreate:s=(()=>{})}){i=n(i);const[u,c,a]={1:["q","r","s"],3:["r","s","q"],5:["s","q","r"]}[o],h=new t;h.width=r,h.height=e,h.start=i,h.direction=o;for(let t=0;t<r;t++)for(let r=0;r<e;r++){const e=n({[u]:t+i[u],[c]:r+i[c],[a]:-t-r+i[a]});s(e,h),h.push(e)}return h}}function w({Grid:t,Hex:n}){return function({size:r,start:e,direction:i=1,onCreate:o=(()=>{})}){e=n(e);const s={1:{rStart:()=>0,rEnd:t=>r-t},5:{rStart:t=>r-t,rEnd:()=>r+1}},{rStart:u,rEnd:c}=s[i],a=new t;a.size=r,a.start=e,a.direction=i;for(let t=0;t<r;t++)for(let r=u(t);r<c(t);r++){const i=n({q:t+e.q,r:r+e.r,s:-t-r+e.s});o(i,a),a.push(i)}return a}}function m({Grid:t,Hex:n}){return function({radius:r,center:e,onCreate:i=(()=>{})}){e=n(e);const o=new t;o.radius=r,o.center=e;for(let t=-r;t<=r;t++){const s=Math.max(-r,-t-r),u=Math.min(r,-t+r);for(let r=s;r<=u;r++){const s=n({q:t+e.q,r:r+e.r,s:-t-r+e.s});i(s,o),o.push(s)}}return o}}function H({Grid:t,Hex:n,compassToNumberDirection:r,signedModulo:e}){return function({width:s,height:u,start:c,direction:a=(n().isPointy()?0:1),onCreate:h=(()=>{})}){c=n(c),i(a)&&(a=r(a,c.orientation)),(a<0||a>5)&&(a=e(a,6));const[f,l,d]=[["q","r","s"],["r","q","s"],["r","s","q"],["s","r","q"],["s","q","r"],["q","s","r"]][a],[x,y]=c.isPointy()?[s,u]:[u,s],p=new t;p.width=s,p.height=u,p.start=c,p.direction=a;for(let t=0;t<y;t++){const r=o(c.offset,t);for(let e=-r;e<x-r;e++){const r=n({[f]:e+c[f],[l]:t+c[l],[d]:-e-t+c[d]});h(r,p),p.push(r)}}return p}}function O({Grid:t,Hex:n}){return function({radius:r,center:e,onCreate:i=(()=>{})}){e=n(e);const o=new t;o.radius=r,o.center=e;const{q:s,r:u,s:c}=e;let h=n({q:s,r:u-r,s:c+r});for(let t=0;t<6;t++)for(let e=0;e<r;e++){i(h,o),o.push(h);const{q:r,r:e,s:s}=a[t];h=n({q:h.q+r,r:h.r+e,s:h.s+s})}return o}}function j({Grid:t,Hex:n}){return function({radius:r,center:e,onCreate:i=(()=>{})}){e=n(e);let o=new t;i(e,o),o.push(e);for(let t=1;t<=r;t++)o=o.concat(this.ring({radius:t,center:e,onCreate:i}));return o.radius=r,o.center=e,o}}function M({Point:t}){return function(n,r){let e;return({x:e,y:r}=t(n,r)),t(this.x+e,this.y+r)}}function E({Point:t}){return function(n,r){let e;return({x:e,y:r}=t(n,r)),t(this.x-e,this.y-r)}}function C({Point:t}){return function(n,r){let e;return({x:e,y:r}=t(n,r)),t(this.x*e,this.y*r)}}function N({Point:t}){return function(n,r){let e;return({x:e,y:r}=t(n,r)),t(this.x/e,this.y/r)}}function S({ensureXY:t}){const i={add:M({Point:o}),subtract:E({Point:o}),multiply:C({Point:o}),divide:N({Point:o})};function o(o,s){let u;return u=r(o)?t(o,s):e(o)?t(...o):n(o)?t(o.x,o.y):t(0),Object.assign(Object.create(i),u)}return o}const R=S({ensureXY:c});class v extends Array{static isValidHex(t){return!0===(t||{}).__isHoneycombHex}fill(){throw new TypeError("Grid.prototype.fill is not implemented")}includes(t,n=0){return!!(this.indexOf(t,n)+1)}indexOf(t,n=0){const{length:r}=this;let e=Number(n);for(t=R(t),e=Math.max(e>=0?e:r+e,0);e<r;e++)if(this[e].equals(t))return e;return-1}lastIndexOf(t,n=this.length-1){const{length:r}=this;let e=Number(n);for(t=R(t),e=e>=0?Math.min(e,r-1):r+e;e>=0;e--)if(this[e].equals(t))return e;return-1}push(...t){return super.push(...t.filter(v.isValidHex))}splice(t,n,...r){return null==n?super.splice(t):super.splice(t,n,...r.filter(v.isValidHex))}unshift(...t){return super.unshift(...t.filter(v.isValidHex))}}function T(t,n,r){return n in t?Object.defineProperty(t,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[n]=r,t}function G(t,n){var r=Object.keys(t);if(Object.getOwnPropertySymbols){var e=Object.getOwnPropertySymbols(t);n&&(e=e.filter((function(n){return Object.getOwnPropertyDescriptor(t,n).enumerable}))),r.push.apply(r,e)}return r}function D(t){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?G(Object(r),!0).forEach((function(n){T(t,n,r[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(r)):G(Object(r)).forEach((function(n){Object.defineProperty(t,n,Object.getOwnPropertyDescriptor(r,n))}))}return t}function z(t,n){if(null==t)return{};var r,e,i=function(t,n){if(null==t)return{};var r,e,i={},o=Object.keys(t);for(e=0;e<o.length;e++)r=o[e],n.indexOf(r)>=0||(i[r]=t[r]);return i}(t,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);for(e=0;e<o.length;e++)r=o[e],n.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(t,r)&&(i[r]=t[r])}return i}function V({Hex:t}){return function(...n){return Object.assign(this,t(...n))}}function W(){return{x:this.x,y:this.y}}function I(){return{q:this.q,r:this.r,s:this.s}}function X({q:t,r:n}){let r,e;return this.isPointy()?(r=t+o(this.offset,n),e=n):(r=t,e=n+o(this.offset,t)),{x:r,y:e}}function Y(){return"pointy"===this.orientation.toLowerCase()}function B(){return"flat"===this.orientation.toLowerCase()}function _(){const{xRadius:t}=this.size;return this.isPointy()?t*Math.sqrt(3):2*t}function A(){const{yRadius:t}=this.size;return this.isPointy()?2*t:t*Math.sqrt(3)}function L({Point:t}){return function(){const n=this.width(),r=this.height(),{x:e,y:i}=this.origin;return this.isPointy()?[t(n-e,.25*r-i),t(n-e,.75*r-i),t(.5*n-e,r-i),t(0-e,.75*r-i),t(0-e,.25*r-i),t(.5*n-e,0-i)]:[t(n-e,.5*r-i),t(.75*n-e,r-i),t(.25*n-e,r-i),t(0-e,.5*r-i),t(.25*n-e,0-i),t(.75*n-e,0-i)]}}function k({Point:t}){return function(){const{x:n,y:r}=this.origin;return t(this.width()/2-n,this.height()/2-r)}}function F({Point:t}){return function(){const{q:n,r:r,size:e}=this,{xRadius:i,yRadius:o}=e;let s,u;return this.isPointy()?(s=i*Math.sqrt(3)*(n+r/2),u=3*o/2*r):(s=3*i/2*n,u=o*Math.sqrt(3)*(r+n/2)),t(s,u)}}function U({Point:t,Hex:n}){return function(r,e){const{xRadius:i,yRadius:o}=this.size;let s,u,c;return({x:s,y:e}=t(r,e).subtract(this.center())),this.isPointy()?(u=Math.sqrt(3)*s/(3*i)-e/(3*o),c=2/3*(e/o)):(u=2/3*(s/i),c=Math.sqrt(3)*e/(3*o)-s/(3*i)),n({q:u,r:c,s:-u-c}).round()}}function J({Hex:t,Point:n}){return function(r){const{x:e,y:i}=n(r);return t(this.x+e,this.y+i,D({},this))}}function $({Hex:t,Point:n}){return function(r){const{x:e,y:i}=n(r);return t(this.x-e,this.y-i,D({},this))}}function K({Point:t}){return function(n){if(null!=n&&(e(n)||r(n.x)&&r(n.y))){const{x:r,y:e}=t(n);return this.x===r&&this.y===e}return!1}}function Q(t){return Math.max(Math.abs(this.q-t.q),Math.abs(this.r-t.r),Math.abs(this.s-t.s))}function Z({Hex:t}){return function(){let{q:n,r:r,s:e}=this,i=Math.round(n),o=Math.round(r),s=Math.round(e);const u=Math.abs(n-i),c=Math.abs(r-o),a=Math.abs(e-s);return u>c&&u>a?i=-o-s:c>a?o=-i-s:s=-i-o,t(D({},this,{q:i,r:o,s:s}))}}function tt({Hex:t}){return function(n,r){const e=this.q*(1-r)+n.q*r,i=this.r*(1-r)+n.r*r;return t(D({},this,{q:e,r:i,s:-e-i}))}}function nt({Hex:t}){return function(){const{q:n,r:r,s:e}=f;return t(D({},this,{q:this.q+n,r:this.r+r,s:this.s+e}))}}function rt(){return"".concat(this.x,",").concat(this.y)}const et={thirdCoordinate:function(t,n){return-t-n}};const it=S({ensureXY:c}),ot=function({ensureXY:t,normalizeRadiuses:i,Point:s}){return function(u={}){const c=function({Point:t}){return function(n,r){let e,i,s;return({x:e,y:r}=t(n,r)),this.isPointy()?(i=e-o(this.offset,r),s=r):(i=e,s=r-o(this.offset,e)),{q:i,r:s,s:-i-s}}}({Point:s}),a={__isHoneycombHex:!0,orientation:"pointy",origin:0,size:{xRadius:1,yRadius:1},offset:-1,get q(){return this.cartesianToCube(this).q},get r(){return this.cartesianToCube(this).r},get s(){return this.cartesianToCube(this).s},add:J({Hex:f,Point:s}),cartesian:W,cartesianToCube:c,center:k({Point:s}),coordinates:W,corners:L({Point:s}),cube:I,cubeToCartesian:X,distance:Q,equals:K({Point:s}),fromPoint:U({Point:s,Hex:f}),height:A,isFlat:B,isPointy:Y,lerp:tt({Hex:f}),nudge:nt({Hex:f}),round:Z({Hex:f}),set:V({Hex:f}),subtract:$({Hex:f,Point:s}),toCartesian:X,toCube:c,toPoint:F({Point:s}),toString:rt,width:_},h=Object.assign(a,u);function f(i,o,s={}){let u;if(n(i)){let{q:t,r:n,s:e}=i,c=z(i,["q","r","s"]);if(r(t)||r(n)||r(e)){const r=t+n+e;if(Number.isNaN(r)||r>1e-12)throw new Error("Cube coordinates must have a sum of 0. q: ".concat(t,", r: ").concat(n,", s: ").concat(e,", sum: ").concat(t+n+e,"."));({x:u,y:o}=h.cubeToCartesian({q:t,r:n,s:e}))}else({x:u,y:o}=i);s=c}else e(i)?([u,o]=i,s={}):u=i;return Object.assign(Object.create(h),Object.assign(s,t(u,o)))}return h.size=i(h.size,h.isPointy()),h.origin=s(h.origin),Object.assign(f,et,{toJSON:()=>u}),f}}({ensureXY:c,normalizeRadiuses:function(t,e){if(n(t)){if(r(t.xRadius)&&r(t.yRadius))return t;const{width:n,height:i}=t;if(r(n)&&r(i))return e?{xRadius:n/Math.sqrt(3),yRadius:i/2}:{xRadius:n/2,yRadius:i/Math.sqrt(3)}}if(r(t))return{xRadius:t,yRadius:t};throw new Error("Invalid size: ".concat(t,". Set it as a number or as an object containing width and height."))},Point:it}),st=function({extendHex:t,Grid:n,Point:i}){const{isValidHex:o}=n;return function(c=t()){function a(...t){return t=t.filter(Boolean),e(t[0])&&(0===t[0].length||t[0].some(t=>!r(t)))&&(t=t[0]),new n(...t.map(t=>c(t)))}return Object.assign(a,{Hex:c,isValidHex:o,pointToHex:q({Point:i,Hex:c}),parallelogram:P({Grid:n,Hex:c}),triangle:w({Grid:n,Hex:c}),hexagon:m({Grid:n,Hex:c}),rectangle:H({Grid:n,Hex:c,compassToNumberDirection:u,signedModulo:s}),ring:O({Grid:n,Hex:c}),spiral:j({Grid:n,Hex:c})}),Object.assign(n.prototype,{get:l,hexesBetween:x,hexesInRange:y({isValidHex:o}),neighborsOf:p({isValidHex:o,signedModulo:s,compassToNumberDirection:u}),pointHeight:b,pointWidth:g,set:d({isValidHex:o})}),a}}({extendHex:ot,Grid:v,Point:it});export{it as Point,st as defineGrid,ot as extendHex};
//# sourceMappingURL=honeycomb.esm.min.js.map
